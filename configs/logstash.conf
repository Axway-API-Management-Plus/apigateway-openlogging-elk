
input {
  beats {
      port => 5044
      host => "0.0.0.0"
      include_codec_tag => true
   }
}

filter {
  # The logtype has been set by Filebeat to distinct between OpenLog and TraceLog
  if ([fields][logtype] == "openlog") {
    # Parse the received payload into a JSON-Object
    json {
       source => "[message]"
       target => "[message]"
    }
    # Use the given timestamp from OpenLog for the logstash timestamp send to ElasticSearch
    date {
       match => [ "timestamp", "UNIX_MS" ]
       target => "timestampOriginal"
    }
    # OpenLog contains multiple events for one transaction
    # Events are received for the following categories
    # - circuitPath         - Contains details of the circuit paths executed during a transaction
    # - transactionSummary  - Contains the high-level summary details of a transaction
    # - transactionElement  - Contains detailed information for an indvidual element (leg) of a transaction
    # - trace               - Contains a single trace message generated by an API Gateway process
    # In this aggregation both are joined together into one document before it is send to ElasticSearch
    # https://docs.axway.com/bundle/APIGateway_762_AdministratorGuide_allOS_en_HTML5/page/Content/AdminGuideTopics/admin_open_logging.htm
    # IT IS IMPORTANT, that 
    aggregate {
        # Map different events based on the correlationId
        task_id => "%{correlationId}"
        # Related events are expected to be received with a delay of 10 seconds
        timeout => 10
        # On timeout (after 10 seconds) send the received event anyway.
        push_map_as_event_on_timeout => true
        # The following code is basically 
        # - Handles all types besides trace
        # - Takes over the common information such as correlationId, timestampOriginal, ...
        # - Initializes the transactionElements
        # - takes over individual fields from the event into the aggregated map
        code => "
            map['correlationId'] ||= event.get('correlationId')
            map['timestampOriginal'] ||= event.get('timestampOriginal')
            map['processInfo'] ||= event.get('processInfo')

            map['transactionElements'] ||= {}

            if (event.get('transactionSummary'))
               map['transactionSummary'] ||= event.get('transactionSummary')

               if (event.get('[transactionSummary][serviceContexts]'))
                  map['transactionSummaryContext'] ||= event.get('[transactionSummary][serviceContexts]')[0]
               end
            end

            if (event.get('circuitPath'))
               map['circuitPath'] ||= event.get('circuitPath')
            end


            if (event.get('[transactionElement][leg]') == 0)
               map['transactionElements']['leg0'] ||= event.get('transactionElement')
            end

            if (event.get('[transactionElement][leg]') == 1)
               map['transactionElements']['leg1'] ||= event.get('transactionElement')
            end

            event.cancel()
       "
    }
    # Indicate in the outgoing event this is an openlog event
    mutate {
      add_tag => [ "openlog" ]
    }

  } else if ([fields][logtype] == "trace") {
    if [message] =~ /^#/ {
      drop { }
    }

    if [message] =~ /^\s*$/ {
      drop { }
    }

    grok {
      match => { "message" => "%{LOGLEVEL:level}%{SPACE}%{MONTHDAY:monthDay}\/%{MONTH:month}\/%{YEAR:year}\:%{TIME:time}%{SPACE}\[%{WORD:fluff}\:%{WORD:correlationId}\]\s*%{GREEDYDATA:body}" }
    }

    if [month] == "Jan" {
      mutate {
          add_field => {
              "month_field" => "1"
          }
      }
    }

    if [month] == "Feb" {
      mutate {
          add_field => {
              "month_field" => "2"
          }
      }
    }

    if [month] == "Mar" {
      mutate {
          add_field => {
              "month_field" => "3"
          }
      }
    }

    if [month] == "Apr" {
      mutate {
          add_field => {
              "month_field" => "4"
          }
      }
    }

    if [month] == "May" {
      mutate {
          add_field => {
              "month_field" => "5"
          }
      }
    }

    if [month] == "Jun" {
      mutate {
          add_field => {
              "month_field" => "6"
          }
      }
    }

    if [month] == "Jul" {
      mutate {
          add_field => {
              "month_field" => "7"
          }
      }
    }

    if [month] == "Aug" {
      mutate {
          add_field => {
              "month_field" => "8"
          }
      }
    }

    if [month] == "Sep" {
      mutate {
          add_field => {
              "month_field" => "9"
          }
      }
    }

    if [month] == "Oct" {
      mutate {
          add_field => {
              "month_field" => "10"
          }
      }
    }

    if [month] == "Nov" {
      mutate {
          add_field => {
              "month_field" => "11"
          }
      }
    }

    if [month] == "Dec" {
      mutate {
          add_field => {
              "month_field" => "12"
          }
      }
    }

    mutate {
      add_field => {
        "timestampOriginal" => "%{year}-%{month_field}-%{monthDay}T%{time}Z"
      }

      remove_field => [ "monthDay", "month", "year", "time", "fluff", "body" ]

      add_tag => [ "trace" ]
    }
  }
}

output {
  if "openlog" in [tags] {
    elasticsearch {
      hosts => "elasticsearch1:9200"
      index => "logstash-openlog"
      template => "${HOME}/pipeline/openlog_index_template.json"
      template_overwrite => true
    }
  } else {
    elasticsearch {
      hosts => "elasticsearch1:9200"
      index => "logstash-trace"
    }
  }

  stdout {
    codec => rubydebug
  }
}