input { pipeline { address => "OpenTraffic" } }

filter {
  # Parse the received payload into a JSON-Object
  json {
      source => "[message]"
      target => "[message]"
  }
  # Use the given timestamp from OpenLog for the logstash timestamp send to ElasticSearch
  date {
      match => [ "timestamp", "UNIX_MS" ]
  }
  mutate {
    remove_field => ["agent", "ecs", "log", "host", "timestamp", "tags", "logType"  ]
  }
  # Take the given gatewayName (provided by filebeat) and replace the serviceName with that value 
  mutate {
    add_field => { "[processInfo][gatewayName]" => "%{[gatewayName]}" }
    add_field => { "[processInfo][gatewayRegion]" => "%{[gatewayRegion]}" }
    remove_field => [ "gatewayRegion", "gatewayName", "[processInfo][serviceName]", "[processInfo][domainId]" ]
  }
  if([transactionSummary]) {
    # Put the transactionSummary elements direclty into root
    ruby {
      code => '
        event.get("transactionSummary").each { |k, v|
          event.set(k,v)
        }
        event.remove("transactionSummary")
      '
    }
    # Indicate that this event is send to the summary index
    mutate {
      add_field => { "type" => "transactionSummary" }
    }
  }
  # Schedule-Policy event - Most of the properties are NULL
  if([correlationId]!="000000000000000000000000" and ![circuitPath] and ![transactionElement] and ![path] and ![protocol] and ![protocolSrc]) {
    # Map it into a transaction to display it in the transaction monitor
    mutate { 
      add_field => { 
      "[type]" => "scheduledPolicy"
      "[serviceContext][service]" => "Scheduled policy"
      "[serviceContext][method]" => "N/A"
      "[serviceContext][duration]" => "-1"
      "[finalStatus]" => "Pass"
      "[path]" => "N/A"
      "[statusCode]" => "901"
      "[statusText]" => "OK"
      "[method]" => "N/A"
      } 
      remove_field => "[serviceContexts]"
    }
  # A transactions element (legs) must create an additional transationSummary event and copy some of the information
  } else if([transactionElement]) {
    ruby {
      # Must be re-arragended to support up-serts into ES
      # Also delete the serviceName & operation as they are duplicates within the serviceContext
      code => "
        leg = event.get('transactionElement');
        no = event.get('[transactionElement][leg]');
        legNo = 'leg'.concat(no.to_s);
        event.set('[transactionElements][' + legNo + ']', leg);
        event.remove('[transactionElements][' + legNo + '][serviceName]');
        event.remove('[transactionElements][' + legNo + '][operation]');
        event.remove('[transactionElements][' + legNo + '][status]');
      "
    }
    mutate {
      remove_field => ["transactionElement"]
    }
    # If it leg0 - Copy some of information into the summary
    if([transactionElements][leg0]) {
      clone {
        clones => ['transactionSummary']
      }
      # If it is the cloned object, copy the information form the leg
      if [type] == 'transactionSummary' {
        mutate { 
          copy => { "[transactionElements][leg0][protocolInfo][http][statusText]" => "[statusText]" }
          copy => { "[transactionElements][leg0][protocolInfo][http][status]" => "[statusCode]" }
          copy => { "[transactionElements][leg0][protocolInfo][http][method]" => "[method]" }
          copy => { "[transactionElements][leg0][protocolInfo][http][bytesSent]" => "[bytesSent]" }
          copy => { "[transactionElements][leg0][protocolInfo][http][bytesReceived]" => "[bytesReceived]" }
          remove_field => ["type", "processInfo", "transactionElements"] 
        }
      }
    }
  }
  # If a transactionSummary event is received having a service context map it into a sinle object, as we can have only one
  if([serviceContexts]) {
    # We have only 1 service context - Map the Array into a single object
    ruby {
      code => "
        leg = event.get('[serviceContexts][0]');
        event.set('[serviceContext]', leg);
      "
    }
    mutate {
      # Remove the original serviceContexts
      remove_field => "[serviceContexts]"
      # As the given org belongs to the app, rename it to appOrg to avoid confusion
      rename => ["[serviceContext][org]", "[serviceContext][appOrg]" ]
      # We don't need the App-Client ID
      remove_field => "[serviceContext][client]"
    }
    # If we have a ServiceConext we have to enrich it with the API-Details
    if([serviceContext]) {
        # Create a key for the API
      mutate {
        add_field => { "apiCacheKey" => "%{[path]}" }
      }
      # Lookup the cache with the created API-Key (API-Name---API-Path)
      memcached {
        hosts => "${MEMCACHED}"
        namespace => "api_details"
        get => { "%{apiCacheKey}" => "[apiDetails]" }
      }
      # If we have nothing in the cache, perform the Lookup via the HTTP-Builder API
      if !([apiDetails]) {
        http {
          url => "${API_BUILDER_URL}/api/elk/v1/api/lookup/api"
          query => {
            "apiName" => "%{[serviceContext][service]}"
            "apiPath" => "%{[path]}"
          }
          target_body => "apiDetails"
          add_field => { "[@metadata][updateAPICache]" => "true" }
        }
      }
      # At this point we should have the apiDetails either from the cache or looked up via HTTP
      if([apiDetails]) {
        mutate {
          add_field => { 
            "[serviceContext][apiOrg]" => "%{[apiDetails][organizationName]}"
            "[serviceContext][apiVersion]" => "%{[apiDetails][version]}" 
            "[serviceContext][apiDeprecated]" => "%{[apiDetails][deprecated]}" 
            "[serviceContext][apiState]" => "%{[apiDetails][state]}"
            "[serviceContext][apiSecurity]" => "%{[apiDetails][apiSecurity]}"
            "[serviceContext][requestPolicy]" => "%{[apiDetails][requestPolicy]}"
            "[serviceContext][routingPolicy]" => "%{[apiDetails][routingPolicy]}"
            "[serviceContext][responsePolicy]" => "%{[apiDetails][responsePolicy]}"
            "[serviceContext][faulthandlerPolicy]" => "%{[apiDetails][faulthandlerPolicy]}"
            "[serviceContext][backendBasePath]" => "%{[apiDetails][backendBasePath]}"
          }
        }
        # If the API has been looked up add it to the cache
        if([@metadata][updateAPICache]=="true") {
          memcached {
            hosts => "${MEMCACHED}"
            namespace => "api_details"
            ttl => "${LOOKUP_CACHE_TTL:600}"
            set => { "[apiDetails]" => "%{apiCacheKey}" }
          }
        }
      }
      mutate {
        remove_field => [ "apiDetails", "headers", "updateAPICache", "apiCacheKey" ]
      }
      # If the API-Lookup failed - Clone the event which is send to an Error index and shown in Traffic-Monitor
      if("_httprequestfailure" in [tags]) {
        clone {
          clones => ['errorEvent']
        }
        if [type] == 'errorEvent' {
          # Fill the URI based on the given path to have it shown in Traffic-Monitor
          mutate { add_field => { "[transactionElements][leg0][protocolInfo][http][uri]" => "%{[path]}" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][vhost]" => "Logstash Error" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][method]" => "LOGSTASH" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][status]" => "900" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][statusText]" => "ERROR" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][authSubjectId]" => "ID: %{[correlationId]}" } }
          mutate { replace => { "[serviceContext][method]" => "check the logs" } }
          # Make sure, the Correlation-ID is unique to avoid an update of the original document
          mutate { replace => { "[correlationId]" => "%{[correlationId]}-Error" } }
        }
      }
    }
  }
}

output {
  if [type] == "scheduledPolicy" {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOST}"
      index => "apigw-traffic-scheduled-%{+YYYY.MM}"
      id => "ScheduledPolicies"
    }
  } else if [type] == "transactionSummary" {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOST}"
      index => "apigw-traffic-summary-%{+YYYY.MM}"
      template => "${HOME}/index_templates/traffic_summary_index_template.json"
      template_name => "traffic-summary"
      template_overwrite => true
      document_id => "%{correlationId}"
      action => "update"
      doc_as_upsert => true
      id => "TrafficSummary"
    }
  } else {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOST}"
      index => "apigw-traffic-details-%{+YYYY.MM.dd}"
      template => "${HOME}/index_templates/traffic_details_index_template.json"
      template_name => "traffic-details"
      template_overwrite => true
      document_id => "%{correlationId}"
      action => "update"
      doc_as_upsert => true
      id => "TrafficDetails"
    }
  }
# Enable if you would like to see outgoing event messages
#  stdout {
#    codec => rubydebug
#  }
}