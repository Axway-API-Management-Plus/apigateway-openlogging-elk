input { pipeline { address => "OpenTraffic" } }

filter {
  # Parse the received payload into a JSON-Object
  json {
      source => "[message]"
      target => "[message]"
  }
  # Use the given timestamp from OpenLog for the logstash timestamp send to ElasticSearch
  date {
      match => [ "timestamp", "UNIX_MS" ]
  }
  mutate {
    remove_field => ["agent", "ecs", "log", "host", "timestamp", "tags", "logType"  ]
  }
  # Take the given gatewayName (provided by filebeat) and replace the serviceName with that value 
  mutate {
    add_field => { "[processInfo][gatewayName]" => "%{[gatewayName]}" }
    add_field => { "[processInfo][gatewayRegion]" => "%{[gatewayRegion]}" }
    remove_field => [ "gatewayRegion", "gatewayName", "[processInfo][serviceName]", "[processInfo][domainId]" ]
  }
  # Schedule-Policy event - Most of the properties are NULL
  if([correlationId]!="000000000000000000000000" and ![circuitPath] and ![transactionElement] and ![transactionSummary][path] and ![transactionSummary][protocol] and ![transactionSummary][protocolSrc]) {
    # Map it into a transaction to display it in the transaction monitor
    mutate { 
      add_field => { 
      "[type]" => "scheduledPolicy"
      "[transactionSummary][serviceContext][service]" => "Scheduled policy"
      "[transactionSummary][serviceContext][method]" => "N/A"
      "[transactionElements][leg0][duration]" => "-1"
      "[transactionElements][leg0][finalStatus]" => "Pass"
      "[transactionElements][leg0][protocolInfo][http][uri]" => "N/A"
      "[transactionElements][leg0][protocolInfo][http][status]" => "901"
      "[transactionElements][leg0][protocolInfo][http][statusText]" => "OK"
      "[transactionElements][leg0][protocolInfo][http][method]" => "N/A"
      } 
      remove_field => "[transactionSummary][serviceContexts]"
    }
  # A transactions element (legs) must create a transationSummary event and copies some information
  } else if([transactionElement]) {
    ruby {
      # Must be re-arragended to support up-serts into ES
      # Also delete the serviceName & operation as they are duplicates within the serviceContext
      code => "
        leg = event.get('transactionElement');
        no = event.get('[transactionElement][leg]');
        legNo = 'leg'.concat(no.to_s);
        event.set('[transactionElements][' + legNo + ']', leg);
        event.remove('[transactionElements][' + legNo + '][serviceName]');
        event.remove('[transactionElements][' + legNo + '][operation]');
      "
    }
    mutate {
      remove_field => ["transactionElement"]
    }
    ruby {
      code => "
        require 'pry'
        transactionSummary = LogStash::Event.new
        transactionSummary.set('somefield', 'somevalue')
        new_event_block.call(transactionSummary)
      "
    }
  }
  # If a transactionSummary event is received having a service context map it into a sinle object, as we can have only one
  if([transactionSummary][serviceContexts]) {
    ruby {
      code => "
        leg = event.get('[transactionSummary][serviceContexts][0]');
        event.set('[transactionSummary][serviceContext]', leg);
      "
    }
    mutate {
      # Remove the original serviceContexts
      remove_field => "[transactionSummary][serviceContexts]"
      # As the given org belongs to the app, rename it to appOrg to avoid confusion
      rename => ["[transactionSummary][serviceContext][org]", "[transactionSummary][serviceContext][appOrg]" ]
      # We don't need the App-Client ID
      remove_field => "[transactionSummary][serviceContext][client]"
    }
    # If we have a ServiceConext we have to enrich it with the API-Details
    if([transactionSummary][serviceContext]) {
        # Create a key for the API
      mutate {
        add_field => { "apiCacheKey" => "%{[transactionSummary][path]}" }
      }
      # Lookup the cache with the created API-Key (API-Name---API-Path)
      memcached {
        hosts => "${MEMCACHED}"
        namespace => "api_details"
        get => { "%{apiCacheKey}" => "[apiDetails]" }
      }
      # If we have nothing in the cache, perform the Lookup via the HTTP-Builder API
      if !([apiDetails]) {
        http {
          url => "${API_BUILDER_URL}/api/elk/v1/api/lookup/api"
          query => {
            "apiName" => "%{[transactionSummary][serviceContext][service]}"
            "apiPath" => "%{[transactionSummary][path]}"
          }
          target_body => "apiDetails"
          add_field => { "[@metadata][updateAPICache]" => "true" }
        }
      }
      # At this point we should have the apiDetails either from the cache or looked up via HTTP
      if([apiDetails]) {
        mutate {
          add_field => { 
            "[transactionSummary][serviceContext][apiOrg]" => "%{[apiDetails][organizationName]}"
            "[transactionSummary][serviceContext][apiVersion]" => "%{[apiDetails][version]}" 
            "[transactionSummary][serviceContext][apiDeprecated]" => "%{[apiDetails][deprecated]}" 
            "[transactionSummary][serviceContext][apiState]" => "%{[apiDetails][state]}"
            "[transactionSummary][serviceContext][apiSecurity]" => "%{[apiDetails][apiSecurity]}"
            "[transactionSummary][serviceContext][requestPolicy]" => "%{[apiDetails][requestPolicy]}"
            "[transactionSummary][serviceContext][routingPolicy]" => "%{[apiDetails][routingPolicy]}"
            "[transactionSummary][serviceContext][responsePolicy]" => "%{[apiDetails][responsePolicy]}"
            "[transactionSummary][serviceContext][faulthandlerPolicy]" => "%{[apiDetails][faulthandlerPolicy]}"
            "[transactionSummary][serviceContext][backendBasePath]" => "%{[apiDetails][backendBasePath]}"
          }
        }
        # If the API has been looked up add it to the cache
        if([@metadata][updateAPICache]=="true") {
          memcached {
            hosts => "${MEMCACHED}"
            namespace => "api_details"
            ttl => "${LOOKUP_CACHE_TTL:600}"
            set => { "[apiDetails]" => "%{apiCacheKey}" }
          }
        }
      }
      mutate {
        remove_field => [ "apiDetails", "headers", "updateAPICache", "apiCacheKey" ]
      }
      # If the API-Lookup failed - Clone the event which is send to an Error index and shown in Traffic-Monitor
      if("_httprequestfailure" in [tags]) {
        clone {
          clones => ['errorEvent']
        }
        if [type] == 'errorEvent' {
          # Fill the URI based on the given path to have it shown in Traffic-Monitor
          mutate { add_field => { "[transactionElements][leg0][protocolInfo][http][uri]" => "%{[transactionSummary][path]}" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][vhost]" => "Logstash Error" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][method]" => "LOGSTASH" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][status]" => "900" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][statusText]" => "ERROR" } }
          mutate { replace => { "[transactionElements][leg0][protocolInfo][http][authSubjectId]" => "ID: %{[correlationId]}" } }
          mutate { replace => { "[transactionSummary][serviceContext][method]" => "check the logs" } }
          # Make sure, the Correlation-ID is unique to avoid an update of the original document
          mutate { replace => { "[correlationId]" => "%{[correlationId]}-Error" } }
        }
      }
    }
  }
}

output {
  if [type] == 'errorEvent' {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOST}"
      index => "apigw-traffic-errors-%{+YYYY}"
      template => "${HOME}/index_templates/traffic_details_index_template.json"
      template_name => "traffic-details"
      template_overwrite => true
      document_id => "%{correlationId}"
      action => "update"
      doc_as_upsert => true
      id => "LogstashLoopupErrors"
    }
  } else if [type] == "scheduledPolicy" {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOST}"
      index => "apigw-traffic-scheduled-%{+YYYY.MM}"
      id => "ScheduledPolicies"
    }
  } else {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOST}"
      index => "apigw-traffic-details-%{+YYYY.MM.dd}"
      template => "${HOME}/index_templates/traffic_details_index_template.json"
      template_name => "traffic-details"
      template_overwrite => true
      document_id => "%{correlationId}"
      action => "update"
      doc_as_upsert => true
      id => "StandardTrafficDetails"
    }
  }
# Enable if you would like to see outgoing event messages
#  stdout {
#    codec => rubydebug
#  }
}