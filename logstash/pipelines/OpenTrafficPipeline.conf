input { pipeline { address => "OpenTraffic" } }
# Please note, that this pipeline handles three different event types:
# 1. A transactionSummary which contains summary information
# 2. A transactionElement event, which contains all legs
# 3. A circuitPath event
filter {
  # Parse the received payload into a JSON-Object
  json {
      source => "[message]"
      target => "[message]"
  }
  # Use the given timestamp from OpenLog for the logstash timestamp send to ElasticSearch
  date {
      match => [ "timestamp", "UNIX_MS" ]
  }
  mutate {
    remove_field => ["agent", "ecs", "log", "host", "timestamp", "tags", "logType", "event" ]
  }
  # Take the given gatewayName (provided by filebeat) and replace the serviceName with that value 
  mutate {
    add_field => { "[processInfo][gatewayName]" => "%{[gatewayName]}" }
    add_field => { "[processInfo][gatewayRegion]" => "%{[gatewayRegion]}" }
    remove_field => [ "gatewayRegion", "gatewayName", "[processInfo][serviceName]", "[processInfo][domainId]" ]
    add_field => { "[@metadata][ignoreField][apiPath]" => "" } # Default values for apiPath
    add_field => { "[@metadata][ignoreField][policyName]" => "" } # and policyName used for ingoreLookup
  }
  # First, is to check if the document should be ignored/dropped (configured based on the apiPath or PolicyName)
  if([transactionSummary]) {
    mutate { replace => { "[@metadata][ignoreField][apiPath]" => "%{[transactionSummary][path]}" } }
  } else if ([transactionElement]) {
    mutate { replace => { "[@metadata][ignoreField][apiPath]" => "%{[transactionElement][protocolInfo][http][uri]}" } }
  } else if ([circuitPath]) {
    mutate { replace => { "[@metadata][ignoreField][policyName]" => "%{[circuitPath][0][policy]}" } }
  }
  # Create a cache key for the Policy
  mutate {
    add_field => { "[@metadata][ignoreLookupCacheKey]" => "%{[@metadata][ignoreField][apiPath]}###%{[@metadata][ignoreField][policyName]}" }
  }
  # Lookup the cache is the document should be ignored
  memcached {
    hosts => "${MEMCACHED}"
    namespace => "ignoredAPIs"
    get => { "%{[@metadata][ignoreLookupCacheKey]}" => "[isIgnoreAPI]" }
  }
  # If we don't know yet, consult the API-Builder API
  if !([isIgnoreAPI]) {
    http {
      url => "${API_BUILDER_URL}/api/elk/v1/api/lookup/api/ignore"
      query => {
        "policyName" => "%{[@metadata][ignoreField][policyName]}"
        "apiPath" => "%{[@metadata][ignoreField][apiPath]}"
        "groupId" => "%{[processInfo][groupId]}"
        "region" => "%{[processInfo][gatewayRegion]}"
      }
      cacert => "${API_BUILDER_SSL_CERT}"
      target_body => "isIgnoreAPI"
      add_field => { "[@metadata][updateIsIgnoreCache]" => "true" }
    }
  }
  # Drop the document if it should be ignored
  if ([isIgnoreAPI][ignore]) {
    ruby {
      code => 'logger.debug("Drop API/event as it should be ignored: ", "isIgnoreAPI" => event.get("[isIgnoreAPI]"), "ignoreLookupCacheKey" => event.get("[@metadata][ignoreLookupCacheKey]") );'
    }
    drop {}
  }
  # If the PolicyName or API-Path has been looked up right now add it to the cache
  if([@metadata][updateIsIgnoreCache]=="true") {
    ruby {
      code => 'logger.info("Adding ignore status to cache: ", "isIgnoreAPI" => event.get("[isIgnoreAPI]"), "ignoreLookupCacheKey" => event.get("[@metadata][ignoreLookupCacheKey]") );'
    }
    memcached {
      hosts => "${MEMCACHED}"
      namespace => "ignoredAPIs"
      ttl => "${LOOKUP_CACHE_TTL:600}"
      set => { "[isIgnoreAPI]" => "%{[@metadata][ignoreLookupCacheKey]}" }
    }
  }
  mutate { remove_field => "[isIgnoreAPI]" }

  # Check, if event is a Scheduled-Policy - Most of the properties are NULL
  if([correlationId]!="000000000000000000000000" and ![circuitPath] and ![transactionElement] and ![transactionSummary][path] and ![transactionSummary][protocol] and ![transactionSummary][protocolSrc]) {
    mutate { 
      add_field => { 
      "[type]" => "scheduledPolicy"
      "[transactionSummary][serviceContext][service]" => "Scheduled policy"
      "[transactionSummary][serviceContext][method]" => "N/A"
      "[transactionSummary][duration]" => "-1"
      "[transactionElements][leg0][finalStatus]" => "Pass"
      "[transactionElements][leg0][protocolInfo][http][uri]" => "N/A"
      "[transactionElements][leg0][protocolInfo][http][status]" => "901"
      "[transactionElements][leg0][protocolInfo][http][statusText]" => "OK"
      "[transactionElements][leg0][protocolInfo][http][method]" => "N/A"
      } 
      remove_field => "[transactionSummary][serviceContexts]"
    }
  # For all other events do ...
  } else {
    # If a transactionElement event is received it must be re-arragended to support up-serts into ES
    # Also delete the serviceName & operation as they are duplicates within the serviceContext
    if([transactionElement]) {
      ruby {
        code => "
          leg = event.get('transactionElement');
          no = event.get('[transactionElement][leg]');
          legNo = 'leg'.concat(no.to_s);
          event.set('[transactionElements][' + legNo + ']', leg);
          event.remove('[transactionElements][' + legNo + '][serviceName]');
          event.remove('[transactionElements][' + legNo + '][operation]');
        "
      }
      mutate {
        remove_field => ["transactionElement"]
      }
    }
    # If a transactionSummary event is received having a service context (which is an Array) get the first object and 
    # map it into a sinle object, as we can have only one
    if([transactionSummary][serviceContexts]) {
      ruby {
        # The Array might be empty
        code => "
          if event.get('[transactionSummary][serviceContexts][0]')
            leg = event.get('[transactionSummary][serviceContexts][0]');
            event.set('[transactionSummary][serviceContext]', leg);
          end
        "
      }
      mutate {
        remove_field => "[transactionSummary][serviceContexts]" # Remove the originally received serviceContexts array
        rename => ["[transactionSummary][serviceContext][org]", "[transactionSummary][serviceContext][appOrg]" ]
        remove_field => "[transactionSummary][serviceContext][client]" # We don't need the App-Client ID
        remove_field => "[transactionSummary][serviceContext][duration]" # We don't need the duration on a serviceContext
        remove_field => "[transactionSummary][serviceContext][status]" # Remove the status, as it's a duplicate to the status in the transactionSummary and not given for native APIs (e.g. Healthcheck)
      }
      # If we have a transactionSummary we have to enrich the API-Details (from API-Manager or locally looked up)
      # And only perform the API-Lookup for APIs (http/https) only
      if([transactionSummary] and [transactionSummary][protocol] in ["http", "https"]) {
        # Check, if an apiName is given (not the case for native APIs) to be used for the lookup
        if([transactionSummary][serviceContext][service]) {
          mutate { add_field => { "[@metadata][apiName]" => "%{[transactionSummary][serviceContext][service]}" } }
        } else {
          mutate { add_field => { "[@metadata][apiName]" => "" } }
        }
        # Create a key for the API
        mutate {
          add_field => { "apiCacheKey" => "%{[transactionSummary][path]}###%{[processInfo][groupId]}###%{[processInfo][gatewayRegion]}" }
        }
        # Lookup the cache with the created API-Key (API-Name---API-Path)
        memcached {
          hosts => "${MEMCACHED}"
          namespace => "api_details"
          get => { "%{apiCacheKey}" => "[apiDetails]" }
        }
        # If we have nothing in the cache, perform the Lookup via the HTTP-Builder API, which does a local & API-Manager Lookup
        if !([apiDetails]) {
          http {
            url => "${API_BUILDER_URL}/api/elk/v1/api/lookup/api"
            query => {
              "apiName" => "%{[@metadata][apiName]}"
              "apiPath" => "%{[transactionSummary][path]}"
              "groupId" => "%{[processInfo][groupId]}"
              "region" => "%{[processInfo][gatewayRegion]}"
            }
            cacert => "${API_BUILDER_SSL_CERT}"
            target_body => "apiDetails"
            add_field => { "[@metadata][updateAPICache]" => "true" }
          }
        }
        # At this point we should have the apiDetails either from the cache or looked up via HTTP
        if([apiDetails]) {
          mutate {
            copy => { "[apiDetails][organizationName]" => "[transactionSummary][serviceContext][apiOrg]" }
            copy => { "[apiDetails][version]" => "[transactionSummary][serviceContext][apiVersion]" }
            copy => { "[apiDetails][deprecated]" => "[transactionSummary][serviceContext][apiDeprecated]" }
            copy => { "[apiDetails][state]" => "[transactionSummary][serviceContext][apiState]" }
            copy => { "[apiDetails][apiSecurity]" => "[transactionSummary][serviceContext][apiSecurity]" }
            copy => { "[apiDetails][requestPolicy]" => "[transactionSummary][serviceContext][requestPolicy]" }
            copy => { "[apiDetails][routingPolicy]" => "[transactionSummary][serviceContext][routingPolicy]" }
            copy => { "[apiDetails][responsePolicy]" => "[transactionSummary][serviceContext][responsePolicy]" }
            copy => { "[apiDetails][faulthandlerPolicy]" => "[transactionSummary][serviceContext][faulthandlerPolicy]" }
            copy => { "[apiDetails][backendBasePath]" => "[transactionSummary][serviceContext][backendBasePath]" }
            # Take over configured custom properties for this API
            copy => { "[apiDetails][customProperties]" => "[transactionSummary][customProperties]" }
          }
          # Native APIs don't have a API-Name and Operation (MethodName), take it from the API-Details
          if !([transactionSummary][serviceContext][service]) {
            mutate {
              copy => { "[apiDetails][name]" => "[transactionSummary][serviceContext][service]" }
              copy => { "[apiDetails][method]" => "[transactionSummary][serviceContext][method]" }
            }
          }
          # If the API has been looked up add it to the cache
          if([@metadata][updateAPICache]=="true") {
            ruby {
              code => 'logger.info("Adding API-Lookup details to cache: ", "apiDetails" => event.get("[apiDetails]"), "apiCacheKey" => event.get("[apiCacheKey]") );'
            }
            memcached {
              hosts => "${MEMCACHED}"
              namespace => "api_details"
              ttl => "${LOOKUP_CACHE_TTL:600}"
              set => { "[apiDetails]" => "%{apiCacheKey}" }
            }
          }
        }
        mutate {
          remove_field => [ "apiDetails", "updateAPICache", "apiCacheKey" ]
        }
        # Removed, as the API-Builder will report errors directly into an Elasticsearch index
        # If the API-Lookup failed - Clone the event which is send to an Error index and shown in Traffic-Monitor
        #if("_httprequestfailure" in [tags]) {
        #  clone {
        #    clones => ['errorEvent']
        #  }
        #  if [type] == 'errorEvent' {
        #    # Fill the URI based on the given path to have it shown in Traffic-Monitor
        #    mutate { add_field => { "[http][uri]" => "%{[transactionSummary][path]}" } }
        #    mutate { replace => { "[http][vhost]" => "Logstash Error" } }
        #    mutate { replace => { "[http][method]" => "LOGSTASH" } }
        #    mutate { replace => { "[http][status]" => "900" } }
        #    mutate { replace => { "[http][statusText]" => "ERROR" } }
        #    mutate { replace => { "[http][authSubjectId]" => "ID: %{[correlationId]}" } }
        #    mutate { replace => { "[serviceContext][method]" => "check the logs" } }
        #    # Make sure, the Correlation-ID is unique to avoid an update of the original document
        #    mutate { replace => { "[correlationId]" => "%{[correlationId]}-Error" } }
        #  }
        #}
      }
    }
  }
  # Don't do the following for scheduledPolicy events are just supposed to be shown in the Traffic-Monitor only
  # Summary index is for Kibana dashboards / analytics
  if([type] != "scheduledPolicy") {
    # Transaction Summary information (which is fulfilled at this point) needs to be cloned into a separate summary index
    if [transactionSummary] or [transactionElements][leg0] {
      clone {
        clones => ['summaryIndex']
      }
      if([type] == 'summaryIndex') {
        if([transactionSummary]) {
          # Change status value of transactionSummary to be aligned with finalStatus
          translate {
            field => "[transactionSummary][status]"
            destination => "[transactionSummary][finalStatus]"
            dictionary => {
              "success" => "Pass"
              "failure" => "Fail" 
              "exception" => "Error"
            }
            remove_field => "[transactionSummary][status]"
          }
          # Place all transactionSummary information directlly into the root
          # The path is skipped, as it is duplicated with http.uri and not available for all kind of events
          ruby {
            code => '
              event.remove("[transactionSummary][path]");
              event.get("transactionSummary").each { |k, v|
                event.set(k,v);
              }
              event.remove("transactionSummary");
            '
          }
        }
        # Also we need to copy some leg0 information into the summary index
        if [transactionElements][leg0] {
          mutate { 
            # Before copy - Remove stuff we don't need in the summaryIndex
            remove_field => [
              "[transactionElements][leg0][leg]",
              "[transactionElements][leg0][protocolInfo][recvHeader]",
              "[transactionElements][leg0][protocolInfo][recvHeader]",
              "[transactionElements][leg0][protocolInfo][recvPayload]", 
              "[transactionElements][leg0][protocolInfo][sentPayload]",
              "[transactionElements][leg0][protocolInfo][sentHeader]"
            ]
          }
          ruby {
            # This copies all kind of traffic (http, filetransfer, ...) to the root of the document (e.g. http.status, http.uri, ...)
            code => '
              event.get("[transactionElements][leg0][protocolInfo]").each { |k, v|
                event.set(k,v)
              }
            '
          }
          mutate {
            copy => { "[transactionElements][leg0][duration]" => "[duration]" }
            copy => { "[transactionElements][leg0][finalStatus]" => "[finalStatus]" }
            # Once we have copied - we can remove the original information from the summaryIndex event
            remove_field => ["transactionElements"] 
          }
          # For some requests (OPTIONS, some native calls) the finalStatus is not set - Set it based on the http.status
          if( ![finalStatus] ) {
            if ([http][status] >= 200 and [http][status] <= 299 ) {
              mutate { add_field => { "[finalStatus]" => "Pass" } }
            } else {
              mutate { add_field => { "[finalStatus]" => "Fail" } }
            }
          }
        }
      } 
    }
  }
  mutate { remove_field => ["headers"] }
}

output {
  if [type] == "summaryIndex" or [type] == "scheduledPolicy" {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOSTS}"
      ssl => true
      cacert => "${ELASTICSEARCH_CERT}"
      user => "${LOGSTASH_USERNAME}"
      password => "${LOGSTASH_PASSWORD}"
      index => "apigw-traffic-summary%{[@metadata][regionIndexSuffix]}"
      document_id => "%{correlationId}"
      action => "update"
      doc_as_upsert => true
      id => "TrafficSummary"
    }
  } else {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOSTS}"
      ssl => true
      cacert => "${ELASTICSEARCH_CERT}"
      user => "${LOGSTASH_USERNAME}"
      password => "${LOGSTASH_PASSWORD}"
      index => "apigw-traffic-details%{[@metadata][regionIndexSuffix]}"
      document_id => "%{correlationId}"
      action => "update"
      doc_as_upsert => true
      id => "StandardTrafficDetails"
    }
  }
# Enable if you would like to see outgoing event messages
#  stdout {
#    codec => rubydebug
#  }
}