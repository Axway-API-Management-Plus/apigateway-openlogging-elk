input { pipeline { address => "OpenTraffic" } }
# Please note, that this pipeline handles three different event types:
# 1. A transactionSummary which contains summary information
# 2. A transactionElement event, which contains all legs
# 3. A circuitPath event
filter {
  # Parse the received payload into a JSON-Object
  json {
      source => "[message]"
      target => "[message]"
  }
  # Use the given timestamp from OpenLog for the logstash timestamp send to ElasticSearch
  date {
      match => [ "timestamp", "UNIX_MS" ]
  }
  mutate {
    remove_field => ["agent", "ecs", "log", "host", "timestamp", "tags", "logType"  ]
  }
  # Take the given gatewayName (provided by filebeat) and replace the serviceName with that value 
  mutate {
    add_field => { "[processInfo][gatewayName]" => "%{[gatewayName]}" }
    add_field => { "[processInfo][gatewayRegion]" => "%{[gatewayRegion]}" }
    remove_field => [ "gatewayRegion", "gatewayName", "[processInfo][serviceName]", "[processInfo][domainId]" ]
  }
  # Check, if event is a Scheduled-Policy - Most of the properties are NULL
  if([correlationId]!="000000000000000000000000" and ![circuitPath] and ![transactionElement] and ![transactionSummary][path] and ![transactionSummary][protocol] and ![transactionSummary][protocolSrc]) {
    mutate { 
      add_field => { 
      "[type]" => "scheduledPolicy"
      "[transactionSummary][serviceContext][service]" => "Scheduled policy"
      "[transactionSummary][serviceContext][method]" => "N/A"
      "[transactionElements][leg0][duration]" => "-1"
      "[transactionElements][leg0][finalStatus]" => "Pass"
      "[transactionElements][leg0][protocolInfo][http][uri]" => "N/A"
      "[transactionElements][leg0][protocolInfo][http][status]" => "901"
      "[transactionElements][leg0][protocolInfo][http][statusText]" => "OK"
      "[transactionElements][leg0][protocolInfo][http][method]" => "N/A"
      } 
      remove_field => "[transactionSummary][serviceContexts]"
    }
  # For all other events do ...
  } else {
    # If a transactionElement event is received it must be re-arragended to support up-serts into ES
    # Also delete the serviceName & operation as they are duplicates within the serviceContext
    if([transactionElement]) {
      ruby {
        code => "
          leg = event.get('transactionElement');
          no = event.get('[transactionElement][leg]');
          legNo = 'leg'.concat(no.to_s);
          event.set('[transactionElements][' + legNo + ']', leg);
          event.remove('[transactionElements][' + legNo + '][serviceName]');
          event.remove('[transactionElements][' + legNo + '][operation]');
        "
      }
      mutate {
        remove_field => ["transactionElement"]
      }
    }
    # If a transactionSummary event is received having a service context map it into a sinle object, as we can have only one
    if([transactionSummary][serviceContexts]) {
      ruby {
        code => "
          leg = event.get('[transactionSummary][serviceContexts][0]');
          event.set('[transactionSummary][serviceContext]', leg);
        "
      }
      mutate {
        remove_field => "[transactionSummary][serviceContexts]"
        rename => ["[transactionSummary][serviceContext][org]", "[transactionSummary][serviceContext][appOrg]" ]
        remove_field => "[transactionSummary][serviceContext][client]" # We don't need the App-Client ID
      }
      # If we have a ServiceConext we have to enrich it with the API-Details
      if([transactionSummary][serviceContext]) {
          # Create a key for the API
        mutate {
          add_field => { "apiCacheKey" => "%{[transactionSummary][path]}" }
        }
        # Lookup the cache with the created API-Key (API-Name---API-Path)
        memcached {
          hosts => "${MEMCACHED}"
          namespace => "api_details"
          get => { "%{apiCacheKey}" => "[apiDetails]" }
        }
        # If we have nothing in the cache, perform the Lookup via the HTTP-Builder API
        if !([apiDetails]) {
          http {
            url => "${API_BUILDER_URL}/api/elk/v1/api/lookup/api"
            query => {
              "apiName" => "%{[transactionSummary][serviceContext][service]}"
              "apiPath" => "%{[transactionSummary][path]}"
            }
            target_body => "apiDetails"
            add_field => { "[@metadata][updateAPICache]" => "true" }
          }
        }
        # At this point we should have the apiDetails either from the cache or looked up via HTTP
        if([apiDetails]) {
          mutate {
            add_field => { 
              "[transactionSummary][serviceContext][apiOrg]" => "%{[apiDetails][organizationName]}"
              "[transactionSummary][serviceContext][apiVersion]" => "%{[apiDetails][version]}" 
              "[transactionSummary][serviceContext][apiDeprecated]" => "%{[apiDetails][deprecated]}" 
              "[transactionSummary][serviceContext][apiState]" => "%{[apiDetails][state]}"
              "[transactionSummary][serviceContext][apiSecurity]" => "%{[apiDetails][apiSecurity]}"
              "[transactionSummary][serviceContext][requestPolicy]" => "%{[apiDetails][requestPolicy]}"
              "[transactionSummary][serviceContext][routingPolicy]" => "%{[apiDetails][routingPolicy]}"
              "[transactionSummary][serviceContext][responsePolicy]" => "%{[apiDetails][responsePolicy]}"
              "[transactionSummary][serviceContext][faulthandlerPolicy]" => "%{[apiDetails][faulthandlerPolicy]}"
              "[transactionSummary][serviceContext][backendBasePath]" => "%{[apiDetails][backendBasePath]}"
            }
          }
          # If the API has been looked up add it to the cache
          if([@metadata][updateAPICache]=="true") {
            memcached {
              hosts => "${MEMCACHED}"
              namespace => "api_details"
              ttl => "${LOOKUP_CACHE_TTL:600}"
              set => { "[apiDetails]" => "%{apiCacheKey}" }
            }
          }
        }
        mutate {
          remove_field => [ "apiDetails", "headers", "updateAPICache", "apiCacheKey" ]
        }
        # If the API-Lookup failed - Clone the event which is send to an Error index and shown in Traffic-Monitor
        if("_httprequestfailure" in [tags]) {
          clone {
            clones => ['errorEvent']
          }
          if [type] == 'errorEvent' {
            # Fill the URI based on the given path to have it shown in Traffic-Monitor
            mutate { add_field => { "[transactionElements][leg0][protocolInfo][http][uri]" => "%{[transactionSummary][path]}" } }
            mutate { replace => { "[transactionElements][leg0][protocolInfo][http][vhost]" => "Logstash Error" } }
            mutate { replace => { "[transactionElements][leg0][protocolInfo][http][method]" => "LOGSTASH" } }
            mutate { replace => { "[transactionElements][leg0][protocolInfo][http][status]" => "900" } }
            mutate { replace => { "[transactionElements][leg0][protocolInfo][http][statusText]" => "ERROR" } }
            mutate { replace => { "[transactionElements][leg0][protocolInfo][http][authSubjectId]" => "ID: %{[correlationId]}" } }
            mutate { replace => { "[transactionSummary][serviceContext][method]" => "check the logs" } }
            # Make sure, the Correlation-ID is unique to avoid an update of the original document
            mutate { replace => { "[correlationId]" => "%{[correlationId]}-Error" } }
          }
        }
      }
    }
  }
  # Don't do the following for Error-Events, as ErrorEvents are just supposed to be shown in the Traffic-Monitor
  if([type] != "errorEvent") {
    # Transaction Summary information (which is fulfilled at this point) needs to be cloned into a separate summary index
    if([transactionSummary]) {
      clone {
        clones => ['summaryIndex']
      }
      if [type] == 'summaryIndex' {
        # Place all transactionSummary information direclty into root
        ruby {
          code => '
            event.get("transactionSummary").each { |k, v|
              event.set(k,v)
            }
            event.remove("transactionSummary")
          '
        }
      }
    # Also we need to copy some leg0 information into the summary index
    } else if([transactionElements][leg0]) {
      clone {
        clones => ['summaryIndex']
      }
      if [type] == 'summaryIndex' {
        mutate { 
          copy => { "[transactionElements][leg0][protocolInfo][http][statusText]" => "[statusText]" }
          copy => { "[transactionElements][leg0][protocolInfo][http][status]" => "[statusCode]" }
          copy => { "[transactionElements][leg0][protocolInfo][http][method]" => "[method]" }
          copy => { "[transactionElements][leg0][protocolInfo][http][bytesSent]" => "[bytesSent]" }
          copy => { "[transactionElements][leg0][protocolInfo][http][bytesReceived]" => "[bytesReceived]" }
          remove_field => ["processInfo", "transactionElements"] 
        }
      }
    }
  }
}

output {
  if [type] == "scheduledPolicy" {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOST}"
      index => "apigw-traffic-scheduled-%{+YYYY.MM}"
      id => "ScheduledPolicies"
    }
  } else if [type] == "summaryIndex" {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOST}"
      index => "apigw-traffic-summary-%{+YYYY.MM}"
      template => "${HOME}/index_templates/traffic_summary_index_template.json"
      template_name => "traffic-summary"
      template_overwrite => true
      document_id => "%{correlationId}"
      action => "update"
      doc_as_upsert => true
      id => "TrafficSummary"
    }
  } else {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOST}"
      index => "apigw-traffic-details-%{+YYYY.MM.dd}"
      template => "${HOME}/index_templates/traffic_details_index_template.json"
      template_name => "traffic-details"
      template_overwrite => true
      document_id => "%{correlationId}"
      action => "update"
      doc_as_upsert => true
      id => "StandardTrafficDetails"
    }
  }
# Enable if you would like to see outgoing event messages
  stdout {
    codec => rubydebug
  }
}