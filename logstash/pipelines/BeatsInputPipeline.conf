input {
  beats {
      id => "BeatsInput"
      port => 5044
      host => "0.0.0.0"
      include_codec_tag => true
   }
}

filter {
  # Check at API-Builder if Filebeat & Logstash have the correct version
  # according to the API-Builder release
  # Lookup versionCheck status at memcache
  memcached {
    hosts => "${MEMCACHED}"
    namespace => "versions_checked"
    get => { "versionCheck" => "[versionChecked]" }
  }
  # If the version has no yet checked, perform a lookup at API-Builder
  if !([versionChecked]) {
    http {
      url => "${API_BUILDER_URL}/api/elk/v1/api/version/check"
      query => {
        "filebeatVersion" => "%{[filebeatVersion]}"
        "logstashVersion" => "2"
      }
      cacert => "${API_BUILDER_SSL_CERT}"
      target_body => "versionStatus"
      add_field => { "[@metadata][updateVersionCheckCache]" => "true" }
    }
  }
  # If the version has just checked, add it to the cache to avoid further lookups
  if([@metadata][updateVersionCheckCache]=="true") {
    memcached {
      hosts => "${MEMCACHED}"
      namespace => "version_status"
      ttl => "86400" # Don't validate the version again for almost ever (let's say the next 24 hours)
      set => { "[versionChecked]" => "versionCheck" }
    }
    # Check if there is a configuration/version mismatch
    if([versionStatus][versionStatus]!="ok") {
      ruby {
        code => "
          logger.info('Exit Logstash as version of Filebeat or Logstash does not match to API-Builder version. Check API-Builder logs for more details');
          Process::exit;
        "
      }
    }
    # Remove fields not used any further
    mutate {
      remove_field => [ "versionStatus", "filebeatVersion" ]
    }
  }

  # If no region is given, set it to an empty string
  if([gatewayRegion]=="N/A") {
    mutate { 
      add_field => { "[@metadata][regionIndexSuffix]" => "" }
    }
  } else {
    # The region is used to create data in regional indices
    mutate { 
      add_field => { "[@metadata][regionIndexSuffix]" => "-%{[gatewayRegion]}" }
    }
    # And it must be lowercase, as indicies in ES must be lowercase
    mutate {
      lowercase => [ "[@metadata][regionIndexSuffix]" ]
    }
  }
  # Cache-Lookup if the index for the region has been created before
  memcached {
    hosts => "${MEMCACHED}"
    namespace => "index_status"
    get => { "%{logtype}###%{gatewayRegion}" => "[indexExists]" }
  }
  # If we have nothing in the cache it can be assumed the required indicies do not exists
  # call the API at API-Builder to create the required indicies if needed
  if !([indexExists]) {
    http {
      url => "${API_BUILDER_URL}/api/elk/v1/api/index/%{logtype}"
      body_format => "json"
      verb => "POST"
      query => {
        "region" => "%{[gatewayRegion]}"
      }
      cacert => "${API_BUILDER_SSL_CERT}"
      target_body => "indexExists"
      add_field => { "[@metadata][updateCache]" => "true" }
    }
  } else {
    # Set a flag that is used only by "Logstash tests" to validate the information was looked up from the cache
    if ([integrationTest]) {
      mutate {
        add_field => { "[cachedResponse]" => "true" }
      }
    }
  }
  # If the API-Builder create index API has been called, create a cache entry to avoid further unneeded calls
  if([@metadata][updateCache]=="true") {
    memcached {
      hosts => "${MEMCACHED}"
      namespace => "index_status"
      ttl => "3600" # Should not be checked anymore for the next hour
      set => { "[indexExists]" => "%{logtype}###%{gatewayRegion}" }
    }
  }
  # Remove the headers returned by the Logstash HTTP filter - we don't need them
  mutate {
    remove_field => [ "headers" ]
  }
}

# Depending on the logtype forward the event to the processing pipeline
output {
  if [logtype] == "openlog" {
      pipeline { 
        send_to => "OpenTraffic" 
        id => "OpenTraffic"
      }
  } else if [logtype] == "trace" {
      pipeline { 
        send_to => "TraceMessages" 
        id => "TraceMessages"
      }
  } else if [logtype] == "events" {
      pipeline { 
        send_to => "Events" 
        id => "Events"
      }
  } else if [logtype] == "domainaudit" {
      pipeline { 
        send_to => "DomainAudit" 
        id => "DomainAudit"
      }
  } else {
    elasticsearch {
      hosts => "${ELASTICSEARCH_HOSTS}"
      ssl => true
      cacert => "${ELASTICSEARCH_CERT}"
      user => "${LOGSTASH_USERNAME}"
      password => "${LOGSTASH_PASSWORD}"
      index => "errors-%{+YYYY.MM.dd}"
    }
  }
# Enable if you would like to see outgoing event messages
#  stdout {
#    codec => rubydebug {
#      metadata => true
#    }
#  }
}